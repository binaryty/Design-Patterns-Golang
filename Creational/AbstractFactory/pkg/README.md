# Задание 1. 
Реализовать иерархию классов, определяющих два вида элементов управления _(controls)_: кнопки _(buttons)_ и метки _(labels)_. 
Абстрактные классы **AbstractButton** и **AbstractLabel** содержат метод _GetControl_, возвращающий строковое представление 
соответствующего элемента управления. Конкретные классы **Button1**, **Button2**, **Label1**, **Label2** включают конструктор 
со строковым параметром _text_, который определяет текст, отображаемый на элементе управления (текст хранится в поле _text_). 
Конкретные классы отличаются видом строкового представления. Для **Button1** и **Label1** (первый вариант представления) 
текст отображается заглавными буквами, кнопки обрамляются квадратными скобками (например, [CAPTION]), метки обрамляются 
символами «=» (например, =MESSAGE=). Для **Button2** и **Label2** (второй вариант представления) текст отображается строчными 
буквами, кнопки обрамляются угловыми скобками (например, <caption>), метки обрамляются двойными кавычками (например, "message").

Реализовать иерархию классов **ControlFactory** (абстрактная фабрика), **Factory1** и **Factory2** (конкретные фабрики). 
Каждый класс содержит два метода: _CreateButton(text)_ и _CreateLabel(text)_. Для **ControlFactory** эти методы являются 
абстрактными, для конкретных фабрик они возвращают кнопку и метку соответствующего вида (первого или второго).

Также реализовать класс **Client**, предназначенный для формирования набора элементов управления. Конструктор данного 
класса принимает параметр _f_ типа **ControlFactory**, который в дальнейшем используется для генерации элементов управления 
требуемого типа. 
Класс **Client** включает метод _AddButton(text)_ для добавления в набор новой кнопки, метод _AddLabel(text)_ для добавления 
в набор новой метки и метод _GetControls_, возвращающий текстовое представление полученного набора элементов управления. 
В текстовом представлении каждый последующий элемент отделяется от предыдущего одним пробелом.